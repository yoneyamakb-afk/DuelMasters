using System.Collections.Immutable;
using System.Linq;

namespace DuelMasters.Engine;

public sealed record PlayerState(
    PlayerId Id,
    Zone Deck,
    Zone Hand,
    Zone Battle,
    ImmutableArray<int> BattleIds,
    Zone Mana,
    Zone Shield,
    Zone Graveyard
);

public sealed record GameState
{
    public PlayerId ActivePlayer { get; init; }
    public PlayerId PriorityPlayer { get; init; }
    public TurnPhase Phase { get; init; }
    public ImmutableArray<PlayerState> Players { get; init; } = ImmutableArray<PlayerState>.Empty;
    public StackState Stack { get; init; } = StackState.Empty;
    public IRandomSource Rng { get; init; } = new DefaultRandom(1);
    public int ConsecutivePasses { get; init; }
    public int TurnNumber { get; init; }
    public ImmutableArray<PowerBuff> ContinuousEffects { get; init; } = ImmutableArray<PowerBuff>.Empty;
    public ICardDatabase? CardDb { get; init; }
    public int NextInstanceId { get; init; }
    public ImmutableArray<TriggeredAbility> PendingTriggers { get; init; } = ImmutableArray<TriggeredAbility>.Empty;
    public GameResult? GameOverResult { get; init; }

    private GameState(PlayerId active, PlayerId priority, TurnPhase phase,
        ImmutableArray<PlayerState> players, StackState stack, IRandomSource rng,
        int passes, int turnNumber, int nextInstanceId,
        GameResult? gameOver = null, ImmutableArray<PowerBuff>? effects = null, ICardDatabase? cardDb = null)
    {
        ActivePlayer = active;
        PriorityPlayer = priority;
        Phase = phase;
        Players = players;
        Stack = stack;
        Rng = rng;
        ConsecutivePasses = passes;
        TurnNumber = turnNumber;
        NextInstanceId = nextInstanceId;
        GameOverResult = gameOver;
        ContinuousEffects = effects ?? ContinuousEffects;
        CardDb = cardDb ?? CardDb;
    }

    public static GameState Create(Deck a, Deck b, int seed)
    {
        var p0 = new PlayerState(new PlayerId(0),
            new Zone(ZoneKind.Deck, a.Cards),
            new Zone(ZoneKind.Hand, ImmutableArray<CardId>.Empty),
            new Zone(ZoneKind.Battle, ImmutableArray<CardId>.Empty),
            ImmutableArray<int>.Empty,
            new Zone(ZoneKind.Mana, ImmutableArray<CardId>.Empty),
            new Zone(ZoneKind.Shield, ImmutableArray<CardId>.Empty),
            new Zone(ZoneKind.Graveyard, ImmutableArray<CardId>.Empty));

        var p1 = new PlayerState(new PlayerId(1),
            new Zone(ZoneKind.Deck, b.Cards),
            new Zone(ZoneKind.Hand, ImmutableArray<CardId>.Empty),
            new Zone(ZoneKind.Battle, ImmutableArray<CardId>.Empty),
            ImmutableArray<int>.Empty,
            new Zone(ZoneKind.Mana, ImmutableArray<CardId>.Empty),
            new Zone(ZoneKind.Shield, ImmutableArray<CardId>.Empty),
            new Zone(ZoneKind.Graveyard, ImmutableArray<CardId>.Empty));

        var rng = new DefaultRandom(seed);
        var gs = new GameState(new PlayerId(0), new PlayerId(0), TurnPhase.Main,
            ImmutableArray.Create(p0, p1), StackState.Empty, rng, 0, 0, 1);
        for (int i=0;i<5;i++) { gs = gs.GiveShield(new PlayerId(0)).GiveShield(new PlayerId(1)); }
        for (int i=0;i<5;i++) { gs = gs.Draw(new PlayerId(0)).Draw(new PlayerId(1)); }
        return gs;
    }

    public GameState With(PlayerId? active = null, PlayerId? priority = null, TurnPhase? phase = null,
        ImmutableArray<PlayerState>? players = null, StackState? stack = null, IRandomSource? rng = null,
        int? passes = null, int? turnNumber = null, int? nextInstanceId = null,
        GameResult? gameOver = null, ImmutableArray<PowerBuff>? effects = null, ICardDatabase? cardDb = null)
        => new GameState(active ?? ActivePlayer, priority ?? PriorityPlayer, phase ?? Phase,
            players ?? Players, stack ?? Stack, rng ?? Rng,
            passes ?? ConsecutivePasses, turnNumber ?? TurnNumber, nextInstanceId ?? NextInstanceId,
            gameOver ?? GameOverResult, effects ?? ContinuousEffects, cardDb ?? CardDb);

    private GameState GiveShield(PlayerId p)
    {
        var ps = Players[p.Value];
        if (ps.Deck.Cards.Length == 0) return this;
        var top = ps.Deck.Cards[0];
        var nd = new Zone(ZoneKind.Deck, ps.Deck.Cards.RemoveAt(0));
        var ns = new Zone(ZoneKind.Shield, ps.Shield.Cards.Add(top));
        var np = ps with { Deck = nd, Shield = ns };
        return With(players: Players.SetItem(p.Value, np));
    }

    private GameState Draw(PlayerId p)
    {
        var ps = Players[p.Value];
        if (ps.Deck.Cards.Length == 0) return this with { GameOverResult = p.Opponent().Value==0? GameResult.Player0Win: GameResult.Player1Win };
        var top = ps.Deck.Cards[0];
        var nd = new Zone(ZoneKind.Deck, ps.Deck.Cards.RemoveAt(0));
        var nh = new Zone(ZoneKind.Hand, ps.Hand.Cards.Add(top));
        var np = ps with { Deck = nd, Hand = nh };
        return With(players: Players.SetItem(p.Value, np));
    }

    public System.Collections.Generic.IEnumerable<ActionIntent> GenerateLegalActions(PlayerId p)
    {
        yield return new ActionIntent(ActionType.PassPriority);
        var me = Players[p.Value];
        if (me.Hand.Cards.Length > 0)
            yield return new ActionIntent(ActionType.SummonDummyFromHand, 0);
        if (me.Battle.Cards.Length > 0)
            yield return new ActionIntent(ActionType.BuffOwnCreature, 0);
        var opp = Players[p.Opponent().Value];
        if (opp.Battle.Cards.Length > 0)
            yield return new ActionIntent(ActionType.DestroyOpponentCreature, 0);
        if (Stack.Items.Length > 0)
            yield return new ActionIntent(ActionType.ResolveTop);
    }

    public GameState Apply(ActionIntent intent)
    {
        var after = this;
        switch (intent.Type)
        {
            case ActionType.PassPriority:
                after = after with { PriorityPlayer = PriorityPlayer.Opponent(), ConsecutivePasses = ConsecutivePasses + 1 };
                if (after.ConsecutivePasses >= 2)
                {
                    if (after.Stack.Items.Length > 0)
                    {
                        after = after.ResolveTopInternal();
                        after = after with { ConsecutivePasses = 0 };
                    }
                    else
                    {
                        after = after with { ConsecutivePasses = 0, TurnNumber = TurnNumber + 1, ActivePlayer = ActivePlayer.Opponent(), PriorityPlayer = ActivePlayer.Opponent() };
                    }
                }
                break;

            case ActionType.SummonDummyFromHand:
            {
                var p = Players[PriorityPlayer.Value];
                if (p.Hand.Cards.Length == 0) break;
                var card = p.Hand.Cards[0];
                var newHand = new Zone(ZoneKind.Hand, p.Hand.Cards.RemoveAt(0));
                var newBattle = new Zone(ZoneKind.Battle, p.Battle.Cards.Add(card));
                var newIds = p.BattleIds.Add(this.NextInstanceId);
                var newPlayer = p with { Hand = newHand, Battle = newBattle, BattleIds = newIds };
                after = this.With(players: Players.SetItem(PriorityPlayer.Value, newPlayer), nextInstanceId: this.NextInstanceId + 1);
                after = after.RunStateBasedActions();
                break;
            }

            case ActionType.BuffOwnCreature:
            {
                var bi = intent.Param;
                var me = Players[PriorityPlayer.Value];
                if (bi >= 0 && bi < me.Battle.Cards.Length)
                {
                    var inst = me.BattleIds[bi];
                    after = after with { ContinuousEffects = after.ContinuousEffects.Add(new PowerBuff(PriorityPlayer, inst, 1000, after.TurnNumber)) };
                }
                after = after.RunStateBasedActions();
                break;
            }

            case ActionType.DestroyOpponentCreature:
            {
                var opp = PriorityPlayer.Opponent();
                var bi = intent.Param;
                var oppP = after.Players[opp.Value];
                if (bi >= 0 && bi < oppP.Battle.Cards.Length)
                {
                    var cid = oppP.Battle.Cards[bi];
                    var bz = oppP.Battle.Cards;
                    var newBattle = new Zone(ZoneKind.Battle, bz.RemoveAt(bi));
                    var newIds = oppP.BattleIds.RemoveAt(bi);
                    var newGy = new Zone(ZoneKind.Graveyard, oppP.Graveyard.Cards.Add(cid));
                    var newOpp = oppP with { Battle = newBattle, Graveyard = newGy, BattleIds = newIds };
                    after = after.With(players: after.Players.SetItem(opp.Value, newOpp));
                    after = after with { PendingTriggers = after.PendingTriggers.Add(new TriggeredAbility(opp, TriggerKind.OnCreatureDestroyed, $"cid={cid.Value}")) };
                }
                after = after.RunStateBasedActions();
                break;
            }

            case ActionType.ResolveTop:
                after = after.ResolveTopInternal();
                break;
        }
        return after;
    }

    private GameState ResolveTopInternal()
    {
        var pop = Stack.Pop();
        if (pop is null) return this;
        var (item, rest) = pop.Value;
        var after = this with { Stack = rest };

        switch (item.Kind)
        {
            case StackItemKind.BuffPower:
                break;
            case StackItemKind.TriggerDemo:
                break;
        }

        after = after.RunStateBasedActions();
        after = after.ProcessTriggers();
        return after;
    }

    public GameState RunStateBasedActions()
    {
        var after = StateBasedActions.Fix(this);
        // ← ここを追加：SBAで溜まったPendingTriggersを即スタックへ
        if (!after.PendingTriggers.IsDefaultOrEmpty && after.PendingTriggers.Length > 0)
            after = after.ProcessTriggers();
        return after;
    }


    private GameState ProcessTriggers()
    {
        if (PendingTriggers.IsDefaultOrEmpty || PendingTriggers.Length == 0)
            return this;

        var ap = this.ActivePlayer;
        var nap = ap.Opponent();

        var first  = PendingTriggers.Where(t => t.Controller.Value == ap.Value);
        var second = PendingTriggers.Where(t => t.Controller.Value == nap.Value);

        var s = this with { PendingTriggers = ImmutableArray<TriggeredAbility>.Empty };
        foreach (var t in first)
            s = s with { Stack = s.Stack.Push(new StackItem(StackItemKind.TriggerDemo, t.Controller, TargetSpec.None, t.Info)) };
        foreach (var t in second)
            s = s with { Stack = s.Stack.Push(new StackItem(StackItemKind.TriggerDemo, t.Controller, TargetSpec.None, t.Info)) };

        return s with { PriorityPlayer = ap, ConsecutivePasses = 0 };
    }
}



